package web

import (
	"io/ioutil"
	"net/http"
	"os"
	"time"
	"vendingMaxine/packages/collection"

	"github.com/labstack/echo/v4"

	_ "vendingMaxine/docs" // docs is generated by Swag CLI, you have to import it.
)

//	@title			VendingMaxine
//	@version		1.0
//	@description	A focused internal-developer-portal, to support teams getting the best of the platform. Simple ;)
//	@contact.name	Paulo Aleixo Campos
//	@contact.url	https://github.com/zipizap/vendingMaxine
//	@contact.email	zipizap123@gmail.com
//	@license.name	GPL v3
//  @license.url    https://github.com/zipizap/vendingMaxine/raw/main/LICENSE
//	@host		    localhost:8080

//	@accept json
//	@produce json
//	@schemes http

/*
- All http request and response body should be JSON

*/

type CatalogOverviewResponse []collection.CatalogInfo

// getCatalogOverview godoc
//
// @Summary      All Catalog overview info
// @Description  Get all catalog overview info
// @Tags         catalog, catalogs
// @Produce      json
// @Success      200  {object}  CatalogOverviewResponse
// @Failure      400  {object}  string
// @Failure      404  {object}  string
// @Failure      500  {object}  string
// @Router       /api/v1/catalogs [get]
func getCatalogsOverview(c echo.Context) error {
	f, err := collection.NewFacilitator()
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	var catsInfo CatalogOverviewResponse
	catsInfo, err = f.CatalogsOverview()
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}
	// slog.Debug(colsInfo)
	return c.JSONPretty(http.StatusOK, catsInfo, jsonPrettyIdent)
}

type CollectionOverviewResponse []collection.CollectionInfo

// getCollectionsOverview godoc
//
// @Summary      All Collections overview info
// @Description  Get all collections overview info
// @Tags         collection, collections
// @Produce      json
// @Success      200  {object}  CollectionOverviewResponse
// @Failure      400  {object}  string
// @Failure      404  {object}  string
// @Failure      500  {object}  string
// @Router       /api/v1/collections [get]
func getCollectionsOverview(c echo.Context) error {
	f, err := collection.NewFacilitator()
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	var colsInfo CollectionOverviewResponse
	colsInfo, err = f.CollectionsOverview()
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}
	// slog.Debug(colsInfo)
	return c.JSONPretty(http.StatusOK, colsInfo, jsonPrettyIdent)
}

type CollectionNewRequest struct {
	Name        string `json:"name"`
	CatalogName string `json:"catalogName"`
}

// postCollectionNew godoc
//
// @Summary      Collection - create new
// @Description  Collection - create new
// @Tags         collection
// @Accept       json
// @Produce      json
// @Param		 newcollection body		CollectionNewRequest	true	"create new Collection"
// @Success      200  {object}  string
// @Failure      400  {object}  string
// @Failure      404  {object}  string
// @Failure      500  {object}  string
// @Router       /api/v1/collections [post]
func postCollectionNew(c echo.Context) error {
	req := new(CollectionNewRequest)
	if err := c.Bind(req); err != nil {
		return c.JSONPretty(http.StatusBadRequest, err.Error(), jsonPrettyIdent)
	}

	f, err := collection.NewFacilitator()
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	if err := f.CollectionNew(req.Name, req.CatalogName); err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	return c.JSONPretty(http.StatusOK, "Collection created successfully", jsonPrettyIdent)
}

type CollectionEditRequest struct {
	SchemaJson string `json:"schemaJson"`
	JsonInput  string `json:"jsonInput"`
	JsonOutput string `json:"jsonOutput"`
}

type CollectionEditPrepinfoResponse struct {
	SchemaJson string `json:"schemaJson"`
	JsonInput  string `json:"jsonInput"`
}

// getCollectionEditPrepinfo godoc
//
// @Summary      Collection - prepare Collection edit by requesting existing Collection info
// @Description  Collection - prepare Collection edit by requesting existing Collection info
// @Tags         collection
// @Produce      json
// @Param		 collectionname path		string	true	"prepare Collection edit by requesting existing Collection info"
// @Success      200  {object}  CollectionEditPrepinfoResponse
// @Failure      400  {object}  string
// @Failure      404  {object}  string
// @Failure      500  {object}  string
// @Router       /api/v1/collections/{collectionname} [get]
func getCollectionEditPrepinfo(c echo.Context) error {
	colName := c.Param("collection-name")

	f, err := collection.NewFacilitator()
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	schemaJson, jsonInput, err := f.CollectionEdit_Prepinfo(colName)
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	resp := CollectionEditPrepinfoResponse{
		SchemaJson: schemaJson,
		JsonInput:  jsonInput,
	}

	return c.JSONPretty(http.StatusOK, resp, jsonPrettyIdent)
}

// putCollectionEditSave godoc
//
// @Summary      Collection - initiate Collection edit by putting new Collection info
// @Description  Collection - initiate Collection edit by putting new Collection info
// @Tags         collection
// @Accept       json
// @Produce      json
// @Param		 collectionname path		string	true	"initiate Collection edit by putting new Collection info"
// @Param		 reqbody body		CollectionEditRequest	true	"initiate Collection edit by putting new Collection info"
// @Success      200  {object}  string
// @Failure      400  {object}  string
// @Failure      404  {object}  string
// @Failure      500  {object}  string
// @Router       /api/v1/collections/{collectionname} [put]
func putCollectionEditSave(c echo.Context) error {
	colName := c.Param("collection-name")

	req := new(CollectionEditRequest)
	if err := c.Bind(req); err != nil {
		return c.JSONPretty(http.StatusBadRequest, err.Error(), jsonPrettyIdent)
	}

	f, err := collection.NewFacilitator()
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	if err := f.CollectionEdit_Save(colName, req.SchemaJson, req.JsonInput, req.JsonOutput, "requestingUser"); err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	return c.JSONPretty(http.StatusOK, "Collection update initiated successfully", jsonPrettyIdent)
}

// getCollectionReplayable godoc
//
// @Summary      Collection - download .tgz file collectionReplayableTgz
// @Description  Collection - download .tgz file collectionReplayableTgz
// @Tags         collection
// @Produce      application/x-gzip
// @Param		 collectionname path		string	true	"collection name"
// @Success      200  {file}    file
// @Failure      400  {object}  string
// @Failure      404  {object}  string
// @Failure      500  {object}  string
// @Router       /api/v1/collections/{collection-name}/replayable [get]
func getCollectionReplayable(c echo.Context) error {
	colName := c.Param("collection-name")

	f, err := collection.NewFacilitator()
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	var collectionReplayableTgzTmpFilefullpath string

	collectionReplayableTgz, collectionReplayableTgzBasename, err := f.CollectionReplayable(colName)
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}

	collectionReplayableTgzTmpFile, err := ioutil.TempFile("", collectionReplayableTgzBasename)
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}
	collectionReplayableTgzTmpFilefullpath = collectionReplayableTgzTmpFile.Name()

	err = writeBytesToFile(collectionReplayableTgz, collectionReplayableTgzTmpFilefullpath)
	if err != nil {
		return c.JSONPretty(http.StatusInternalServerError, err.Error(), jsonPrettyIdent)
	}
	//defer os.Remove(collectionReplayableTgzTmpFilefullpath)

	// delete collectionReplayableTgzTmpFilefullpath after 5min
	go func() {
		time.Sleep(5 * time.Minute)
		_ = os.Remove(collectionReplayableTgzTmpFilefullpath)
	}()

	return c.Attachment(collectionReplayableTgzTmpFilefullpath, collectionReplayableTgzBasename+".tgz")
}

// writeBytesToFile writes the given content to the specified file.
// It returns an error if there was any issue while writing to the file.
func writeBytesToFile(content []byte, filename string) error {
	// Open the file in write mode, create it if it doesn't exist, truncate it if it does.
	file, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer file.Close()

	// Write the content to the file.
	_, err = file.Write(content)
	if err != nil {
		return err
	}

	return nil
}
