web:
+ GP  /collection/:collection_name
. G   /login
. G   /logout
+. G   /collections
+ -show status existing collections
 -button_cr_collection
 -button_del_collection

+ collection.
+ .GetCollection(cname string) (col *Collection, err error)
.NewCollection(cname string) (col *Collection, err error)
.DeleteCollection(cname string) (col *Collection, err error)

+ collection.Collection{
+   Name: "alpha",
+ }
+ .LastRsf() (rsf *RequestStatusFlow, err error)
+ .NewRsf_from_WebconsumerSelection(webdata map[string]string)(cantDo bool, rsf *RequestStatusFlow, err error)
+ .dirpath()(colDirpath string, err error)
+ .lastFiles(optional_filename_regexp ...string) ( lastFilesRecentFirst []string, err error)


+ collection.RequestStatusFlow{
+ }
+ .Get_OverallLatestUpdateData_Decoded(key string)(value string, err error)
+ .checkNewRsfCanBeCreated()(yes bool, err error)
+ .new_from_webConsumerSelection(web_sblock StatusBlock) (cantDo bool, err error)
+ .i1_runProcessingEngines() -> async
+ .i1_syncLoadFromLastFile()(err error)
+ .i1_getCollection()(col *Collection, err error)
+ .i1_append_Sblock((new_sblock_is_finalSblock bool, new_sblock StatusBlock)(cantDo bool, err error)
+ .i1_update_LastSblock(new_sblock_is_finalSblock bool, new_sblock StatusBlock)(cantDo bool, err error)
+ .i1_update_Overall_LatestUpdateData(new_LatestUpdateData map[string]interface{})(cantDo bool, err error)
+ .i1_getProcEngineBinariesList() (procEngineBinariesFilepaths []string, err error)
+ .i2_checkRsfCanBeUpdated()(yes bool, err error)
+ .i2_syncSaveToLastFile()(err error)
+ .i2_append_or_update_Sblock(append_or_update string, new_sblock_is_finalSblock bool, new_sblock StatusBlock)
+ .i2_autoupdate_OverallStatus(lastSblock_is_finalSblock bool)(err error)
+   .i3_autoupdate_Overall_LatestUpdateUml() (err error)
+ encode_bytes_to_gzB64(bytes []byte) (gzB64 string, err error)
+ decode_gzB64_to_bytes(gzB64 string) (bytes []byte, err error)

TODO:
>> product.schema use-case
>> "initiation": how to simple/elegant implement it
>>>> NewCollection 
      . see comments in function body
      . (needs "initiation" to create first Rsf of new collection)
      . new-collection: create new collection, create firstrsf that contains selection.next.json to be used in future get-requests
>> subscription as a product, or subscription as a supra-product-delimiter


Improvements:
>> runProcessingEngines: ? deal with internal errors correctly (dont return, but instead update sblock with "Error")?
   Some improvements were made, check if there is still something pending
>> gracefull shutdown of this ever-running-server...
>> generate plantuml images locally (instead of remotely-via-url and js)



NOTES:
- RequestStatusFlow.internalfunc() should be the only one reading/writting into *UserviceFlow and must keep it
  in-sync with file-system unit-service.flow.xxxxx.yaml

-------------------
GetUserviceFlow(uname string) (usf *UserviceFlow, err error)
NewUserviceFlow(uname string) (cantBeDone bool, usf *UserviceFlow, err error)

UserviceFlow_Append_Sblock(uname string, sblock *StatusBlock) (cantBeDone bool, err error)
UserviceFlow_Update_LastSblock(uname string, sblock *StatusBlock) (cantBeDone bool, err error) 
UserviceFlow_Set_cantBeChangedAnymore(uname string) (cantBeDone bool, err error) 
UserviceFlow_Check_cantBeChangedAnymore(uname string) (cantBeDone bool, err error) 


- Dispatcher should be the only one reading/writting into *UserviceFlow and must keep it
  in-sync with file-system unit-service.flow.xxxxx.yaml
   