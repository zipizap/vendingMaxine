package main

import (
	"errors"
	"fmt"
	"os"

	"github.com/davecgh/go-spew/spew"
	log "github.com/sirupsen/logrus"

	cli "github.com/urfave/cli/v2"
)

func init() {
	log.SetFormatter(&log.TextFormatter{
		DisableColors: false,
		FullTimestamp: true,
	})
	spew.Config.Indent = "  "
}

/*
  ## USEFULL NOTES :)

  spew.Dump(...any-object...)

  log.Fatal(err)
  log.Info("info message")
*/

// This is just a placeholder to store flag values, so they can be set by app.Flags and from then on read from here
var ArgsAndFlags = struct {
	args  []string
	flags struct {
		configfile string
	}
}{}

// This function is where all the interesting stuff happens
func app_action(c *cli.Context) error {
	// *arguments* - working with them
	if c.NArg() > 0 {
		ArgsAndFlags.args = c.Args().Slice()
		fmt.Printf("First arg is: %q \n", ArgsAndFlags.args[0])
	}

	// *flags* - working with them
	fmt.Printf("Flag --config is: %+v \n", ArgsAndFlags.flags.configfile)
	fmt.Printf("Flag --config is: %+v \n", c.String("configfile"))

	// Exit-code
	if ArgsAndFlags.args[0] == "exit" {
		// exit from an err:
		err := errors.New("This is my homemade error! Spuff!")
		return cli.Exit(err.Error(), 86)

		// or exit "manually":
		//return cli.Exit("My exit message here - bye bye with exit code 86 ", 86)
	}

	return nil
}

func main() {

	app := &cli.App{
		Name:    "myappname",
		Usage:   "My great app",
		Version: "0.1.2", // --version | -v
		Action:  app_action,
		Flags: []cli.Flag{
			// Global options flags
			&cli.StringFlag{
				Name:        "configfile",                     // --configfile
				Aliases:     []string{"c"},                    // -c               (shortname or alias)
				Usage:       "Load configuration from `FILE`", // help-text:       --configfile FILE, -c FILE   Load configuration from FILE
				Destination: &ArgsAndFlags.flags.configfile,   // save flag value to ArgsAndFlags var
				Value:       "./defaultconfig.yaml",           // default value
				EnvVars:     []string{"APP_CONFIG_FILE"},      // get default-value of flag from env-var (--config/-c  overrides it!)
				Required:    true,                             // [optional] this flag is mandatory?
			},
		},
	}
	app.UseShortOptionHandling = true // let bool-shortnames to be joined: -a -b -c FILE => -abc FILE
	app.EnableBashCompletion = true   // and then users must copy a file "bash_autocomplete" and setup shell with: PROG=myprogram source path/to/cli/autocomplete/bash_autocomplete

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}
